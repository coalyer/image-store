## 第6章 面向对象的程序设计

***1. 本章内容***

- 理解对象属性
- 理解并创建对象
- 理解继承

***2. 对象与引用类型***

面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。ECMAScript 中**没有类**的概念，因此它的对象也与基于类的语言中的对象有所不同。

ECMA-262 把**对象**定义为：**“无序属性的集合，其属性可以包含基本值、对象或者函数。”**严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript 的对象想象成**散列表**：无非就是一组名值对，其中值可以是数据或函数。

每个**对象**都是基于一个**引用类型**创建的，这个引用类型：

- 可以是第5 章讨论的**原生类型**
- 可以是开发人员**定义的类型**

### 6.1 理解对象

***1. 理解对象***

创建自定义对象：

- 最简单方式就是创建一个Object 的实例，然后再为它添加属性和方法。

  ```js
  var person = new Object();
  person.name = "Nicholas";
  person.age = 29;
  person.job = "Software Engineer";
  
  person.sayName = function(){
  	alert(this.name);
  };
  ```

- 对象字面量成为创建这种对象的首选模式。

  ```js
  var person = {
  	name: "Nicholas",
  	age: 29,
  	job: "Software Engineer",
  	sayName: function(){
  		alert(this.name);
  	}
  };
  ```

这些属性在创建时都带有一些**特征值（characteristic）**，JavaScript 通过这些特征值来定义它们的行为。

#### 6.1.1 属性类型

***1. 特性与属性***

ECMA-262 第5 版在定义**只有内部才用的**特性（attribute）时，描述了属性（property）的各种特征。（**attribute** /əˈtrɪbju:t/ 属性; （人或物的） 特征 **property** /ˈprɒpəti/ 特性，属性; 财产，地产; ）

- 这些特性是**为了实现JavaScript 引擎**用的，因此在JavaScript 中不能直接访问它们。
- 为了表示特性是内部值，该规范把它们放在了**两对儿方括**号中，例如[[Enumerable]]。

ECMAScript 中有两种属性：数据属性和访问器属性。

***2. 数据属性***

数据属性包含一个数据值的位置。在这个位置可以读取和写入值。

数据属性有4 个描述其**行为的特性**。

- [[Configurable]]：表示**能否通过delete 删除属性**从而重新定义属性，**能否修改属性的特性**，或者**能否把属性修改为访问器属性**。（不可配置）（**Configurable /kən'fɪgərəbl]/ 结构的，可配置的**;）

- - 直接在对象上定义的属性，它们的这个特性**默认值为true**。

- [[Enumerable]]：表示能**否通过for-in 循环返回属性**。（**Enumerable /ɪ'nju:mərəbə/ 可列举的;**）

- - 直接在对象上定义的属性，它们的这个特性**默认值为true**。

- [[Writable]]：表示**能否修改属性的值**。（只读）

- - 直接在对象上定义的属性，它们的这个特性**默认值为true**。

- [[Value]]：包含这个**属性的数据值**。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。（**特征值**）

- - 这个特性的**默认值为undefined**。

- ```js
  var person = {
  	name: "Nicholas"
  };
  
  ```

- - 它的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为指定的值。
  - [[Value]]特性将被设置为"Nicholas"，而对这个值的任何修改都将反映在这个位置。

要**修改属性默认的特性**，必须使用ECMAScript 5 的Object.defineProperty()方法。

- 这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。

- 描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和value。设置其中的一或多个值，可以修改对应的特性值。

- 举例：设置**只读属性（[[Writable]]）**

  ```js
  var person = {};
  Object.defineProperty(person, "name", {
  	writable: false,
  	value: "Nicholas"
  });
  
  alert(person.name); //"Nicholas"
  person.name = "Greg";
  alert(person.name); //"Nicholas"
  ```

  - 名为name 的属性，它的值"Nicholas"是只读的。属性的值是不可修改的，如果尝试为它指定新值

  - - 在非严格模式下，赋值操作将被忽略；
    - 在严格模式下，赋值操作将会导致抛出错误。

- 举例：设置**不可配置属性（[[Configurable]]）**

  ```js
  var person = {};
  Object.defineProperty(person, "name", {
  	configurable: false,
  	value: "Nicholas"
  });
  
  alert(person.name); //"Nicholas"
  delete person.name;
  alert(person.name); //"Nicholas"
  ```

  - 把configurable 设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，

  - - 在非严格模式下什么也不会发生，
    - 而在严格模式下会导致错误。

  - 而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。

    ```js
    var person = {};
    Object.defineProperty(person, "name", {
    	configurable: false,
    	value: "Nicholas"
    });
    //抛出错误
    Object.defineProperty(person, "name", {
    	configurable: true,
    	value: "Nicholas"
    });
    ```

    - 再调用Object.defineProperty()方法修改除writable 之外的特性，都会导致错误。多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false 之后就会有限制了。

- 在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable 和writable 特性的默认值都是false。

- 多数情况下，可能都没有必要利用Object.defineProperty()方法提供的这些高级功能。不过，理解这些概念对理解JavaScript 对象却非常有用。

- IE8 是第一个实现Object.defineProperty()方法的浏览器版本。然而，这个版本的实现存在诸多限制：只能在DOM对象上使用这个方法，而且只能创建访问器属性。由于实现不彻底，建议读者不要在IE8 中使用Object.defineProperty()方法。

***3. 访问器属性***

- 访问器属性不包含数据值；它们包含一对儿getter 和setter 函数（不过，这两个函数都不是必需的）。

- - 在读取访问器属性时，会调用getter 函数，这个函数负责返回有效的值；
  - 在写入访问器属性时，会调用setter 函数并传入新值，这个函数负责决定如何处理数据。

- 访问器属性有如下4 个特性。

- - [[Configurable]]：表示能否通过delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。

  - - 对于直接在对象上定义的属性，这个特性的默认值为true。

  - [[Enumerable]]：表示能否通过for-in 循环返回属性。

  - - 对于直接在对象上定义的属性，这个特性的默认值为true。

  - [[Get]]：在读取属性时调用的函数。

  - - 默认值为undefined。

  - [[Set]]：在写入属性时调用的函数。

  - - 默认值为undefined。

- **访问器属性不能直接定义**，必须使用Object.defineProperty()来定义。

  ```js
  var book = {
  	_year: 2004,
  	edition: 1
  };
  
  Object.defineProperty(book, "year", {
  	get: function(){
  		return this._year;
  	},
  	set: function(newValue){
  	if (newValue > 2004) {
  			this._year = newValue;
  			this.edition += newValue - 2004;
  		}
  	}
  });
  
  book.year = 2005;
  alert(book.edition); //2
  ```

  - 定义两个默认的属性：_year 和edition。

  - - _year 前面的**下划线是一种常用的记号，用于表示只能通过对象方法访问的属性**。

  - 访问器属性year

  - - 包含一个getter 函数和一个setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此，把year 属性修改为2005 会导致_year 变成 2005，而edition 变为2。

    - 使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。

    - 不一定非要同时指定getter 和setter。

    - - 只指定getter 意味着属性是不能写，

      - - 尝试写入属性会被忽略。
        - 在严格模式下，尝试写入只指定了getter 函数的属性会抛出错误。

      - 只指定setter 函数的属性也不能读，

      - - 在非严格模式下会返回undefined，
        - 而在严格模式下会抛出错误。

- 支持ECMAScript 5 的这个方法的浏览器有IE9+（IE8 只是部分实现）、Firefox 4+、Safari 5+、Opera12+ 和Chrome 。

- 在这个方法之前， 要创建访问器属性，     一般都使用两个非标准的方法：_defineGetter__()和__defineSetter__()。这两个方法最初是由Firefox 引入的

  ```js
  var book = {
  	_year: 2004,
  	edition: 1
  };
  	
  //定义访问器的旧有方法
  book.__defineGetter__("year", function(){
  	return this._year;
  });
  
  book.__defineSetter__("year", function(newValue){
  	if (newValue > 2004) {
  		this._year = newValue;
  		this.edition += newValue - 2004;
  	}
  });
  
  book.year = 2005;
  alert(book.edition); //2
  ```

- 在不支持Object.defineProperty() 方法的浏览器中不能修改[[Configurable]] 和[[Enumerable]]。

#### 6.1.2 定义多个属性

***1. ***

由于为对象定义多个属性的可能性很大，ECMAScript 5 又定义了一个Object.defineProperties()方法。

- 利用这个方法可以通过描述符一次定义多个属性。

- 这个方法接收两个对象参数：

- - 第一个对象是要添加和修改其属性的对象，
  - 第二个对象的属性与第一个对象中要添加或修改的属性一一对应。

- ```js
  var book = {};
  
  Object.defineProperties(book, {
  	_year: {
  		value: 2004
  	},
  	edition: {
  		value: 1
  	},
  	year: {
  		get: function(){
  			return this._year;
  		},
  		set: function(newValue){
  			if (newValue > 2004) {
  				this._year = newValue;
  				this.edition += newValue - 2004;
  			}
  		}
  	}
  });
  ```

- - 定义了两个**数据属性（_year 和edition**）和一个**访问器属性（year）**。最终的对象与上一节中定义的对象相同。（理解：描述符对象的形式创建数据属性）
  - 唯一的区别是这里的属性都是在**同一时间创建**的。

- 支持Object.defineProperties()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。

#### 6.1.3 读取属性的特性

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

### 6.2 创建对象

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.2.1 工厂模式

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.2.2 构造函数模式

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.2.3 原型模式

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.2.4 组合使用构造函数模式和原型模式

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.2.5 动态原型模式

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.2.6 寄生构造函数模式

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.2.7 稳妥构造函数模式

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

### 6.3 继承

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.3.1 原型链

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.3.2 借用构造函数

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.3.3 组合继承

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.3.4 原型式继承

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.3.5 寄生式继承

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 6.3.6 寄生组合式继承

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

### 6.4 小结

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

