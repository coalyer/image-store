## 第5章 引用类型

***1. 本章内容***

- 使用对象
- 创建并操作数组
- 理解基本的JavaScript 类型
- 使用基本类型和基本包装类型

***2. 引用类型（实例）与引用类型的值（类）***

引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。（再去理解：引用类型（实例）与引用类型的值（类））

- 虽然引用类型与**类**看起来相似，但它们并不是相同的概念。为避免混淆，本书将不使用类这个概念。

- 引用类型有时候也被称为**对象定义**，因为它们描述的是一类对象所具有的属性和方法。
- 对象是某个特定**引用类型的实例**，**引用类型的值**。

***3. 构造函数***

新对象是使用new 操作符后跟一个**构造函数**来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。

```js
var person = new Object();
```

- 创建了Object 引用类型的一个新实例，然后把该实例保存在了变量person 中。
- 使用的构造函数是Object，它只为新对象定义了默认的属性和方法。
- ECMAScript 提供了很多原生引用类型（例如Object），以便开发人员用以实现常见的计算任务。

### 5.1 Object类型

***1. 存储和传输数据***

大多数引用类型值都是Object 类型的实例；而且，Object 也是ECMAScript 中使用最多的一个类型。

虽然Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。

***2. 创建Object 实例的方式有两种：***

使用new 操作符后跟Object 构造函数

```js
var person = new Object();
person.name = "Nicholas";
person.age = 29;
```

使用**对象字面量**表示法

```js
var person = {
	name : "Nicholas",
	age : 29
};
```

- ECMAScript 中的表达式上下文（expression context）（{}部分）指的是能够返回一个值（表达式）。赋值操作符表示后面是一个值。

- 在最后一个属性后面添加逗号，会在IE7 及更早版本和Opera 中导致错误。

- 在使用对象字面量语法时，属性名也可以使用字符串

  ```js
  var person = {
  	"name" : "Nicholas",
  	"age" : 29,
  	5 : true
  };
  ```

- 使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象

  ```js
  var person = {}; //与new Object()相同
  person.name = "Nicholas";
  person.age = 29;
  ```

- 在通过对象字面量定义对象时，实际上不会调用Object 构造函数（Firefox 2 及更早版本会调用Object 构造函数；但Firefox 3 之后就不会了）。

***3. 使用对象字面量向函数传递大量参数***

开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。实际上，对象字面量也是向函数传递大量可选参数的首选方式

命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。

```js
function displayInfo(args) {
	var output = "";
	if (typeof args.name == "string"){
		output += "Name: " + args.name + "\n";
	}
	if (typeof args.age == "number") {
		output += "Age: " + args.age + "\n";
	}
	alert(output);
}
displayInfo({
	name: "Nicholas",
	age: 29
});
displayInfo({
	name: "Greg"
});
```

***4. 使用方括号语法***

访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过，在JavaScript 也可以使用方括号表示法来访问对象的属性。

- 在使用方括号语法时，应该将要访问的属性**以字符串的形式**放在方括号中

  ```js
  alert(person["name"]); //"Nicholas"
  alert(person.name); //"Nicholas"
  ```

- 从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过**变量**来访问属性

  ```js
  var propertyName = "name";
  alert(person[propertyName]); //"Nicholas"
  ```

- 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。

  ```js
  person["first name"] = "Nicholas";
  ```

  - 由于"first name"中包含一个空格，所以不能使用点表示法来访问它。然而，属性名中是可以包含非字母非数字的，这时候就可以使用方括号表示法来访问它们。

通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。

### 5.2 Array类型

除了Object 之外，**Array 类型恐怕是ECMAScript 中最常用的类型了**。

***1. 区别***

ECMAScript 中的数组与其他多数语言中的数组有着相当大的区别。虽然ECMAScript 数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是：

- **ECMAScript 数组的每一项可以保存任何类型的数据**。也就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象，以此类推。
- **ECMAScript 数组的大小是可以动态调整的**。即可以随着数据的添加自动增长以容纳新增数据。

***2. 创建数组的基本方式有两种：***

使用Array构造函数

```js
var colors = new Array();
```

- 可以给构造函数传递数量，如果预先知道数组要保存的项目数量。该数量会自动变成length属性的值。

  ```js
  var colors = new Array(20);
  ```

- 可以向Array 构造函数传递数组中应该包含的项。

  ```js
  colors = new Array("red", "blue", "green");
  ```

- 给构造函数传递一个值时候问题就复杂一点了

  ```js
  var colors = new Array(3); // 创建一个包含3 项的数组
  var names = new Array("Greg"); // 创建一个包含1 项，即字符串"Greg"的数组
  ```
  - 如果传递的是数值，则会按照该数值创建包含给定项数的数组
  - 如果传递的是其他类型的参数，则会创建包含那个值的只有一项的数组。

- 另外，在使用Array 构造函数时也可以省略new 操作符。

  ```js
  var colors = Array(3); // 创建一个包含3 项的数组
  var names = Array("Greg"); // 创建一个包含1 项，即字符串"Greg"的数组
  ```

使用数组字面量表示法

```js
 var names = [];
```

- 数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开

  ```js
  var colors = ["red", "blue", "green"]; // 创建一个包含3 个字符串的数组
  var names = []; // 创建一个空数组
  var values = [1,2,]; // 不要这样！这样会创建一个包含2 或3 项的数组
  var options = [,,,,,]; // 不要这样！这样会创建一个包含5 或6 项的数组
  ```

  - 原因是IE8 及之前版本中的ECMAScript 实现在数组字面量方面存在bug。
  - 第三行展示了在数组字面量的最后一项添加逗号的结果：在IE 中，values 会成为一个包含3 个项且每项的值分别为1、2 和undefined 的数组；在其他浏览器中，values 会成为一个包含2 项且值分别为1 和2 的数组。
  - 最后一行代码所示，该行代码可能会创建包含5 项的数组（在IE9+、Firefox、Opera、Safari 和Chrome 中），也可能会创建包含6 项的数组（在IE8 及更早版本中）。

- 与对象一样，在使用数组字面量表示法时，也不会调用Array 构造函数（Firefox 3及更早版本除外）。



***3. 使用数据***

数组的项数保存在其length 属性中，这个属性始终会返回0 或更大的值

```js
var colors = ["red", "blue", "green"]; // 创建一个包含3 个字符串的数组
var names = []; // 创建一个空数组
alert(colors.length); //3
alert(names.length); //0
```

- 如果索引小于数组中的项数，则返回对应项的值
- 如果设置某个值的索引超过了数组现有项数，如这个例子中的colors[3]所示，数组就会自动增加到该索引值加1 的长度（就这个例子而言，索引是3，因此数组长度就是4）。

数组的项数保存在其length 属性中，这个属性始终会返回0 或更大的值

```js
var colors = ["red", "blue", "green"]; // 创建一个包含3 个字符串的数组
var names = []; // 创建一个空数组
alert(colors.length); //3
alert(names.length); //0
```

- 数组的length 属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。

- 移除项

  ```js
  var colors = ["red", "blue", "green"]; // 创建一个包含3 个字符串的数组
  colors.length = 4;
  aler t(colors[3]); //undefined
  ```

  

- 添加新项

  ```js
  var colors = ["red", "blue", "green"]; // 创建一个包含3 个字符串的数组
  colors.length = 4;
  aler t(colors[3]); //undefined
  ```

  - 利用length 属性也可以方便地在数组末尾添加新项

    ```js
    var colors = ["red", "blue", "green"]; // 创建一个包含3 个字符串的数组
    colors[colors.length] = "black"; //（在位置3）添加一种颜色
    colors[colors.length] = "brown"; //（在位置4）再添加一种颜色
    ```

  - 当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值，即长度值等于最后一项的索引加1

    ```js
    var colors = ["red", "blue", "green"]; // 创建一个包含3 个字符串的数组
    colors[99] = "black"; // （在位置99）添加一种颜色
    alert(colors.length); // 100
    ```

***4. 长度***

数组最多可以包含4 294 967 295 个项，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。

#### 5.2.1 检测数组

***1. 经典问题***

自从ECMAScript 3 做出规定以后，就出现了**确定某个对象是不是数组**的经典问题。

***2. 检测数组***

使用instanceof 操作符就能得到满意的结果：

```js
if (value instanceof Array){
	//对数组执行某些操作
}
```

- instanceof 操作符的问题在于，它**假定只有一个全局执行环境**。

- 如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

为了解决这个问题，ECMAScript 5 新增了Array.isArray()方法：

```js
if (Array.isArray(value)){
	//对数组执行某些操作
}
```

- 这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。
- 支持Array.isArray()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 10.5+和Chrome。要在尚未实现这个方法中的浏览器中准确检测数组，请参考22.1.1 节。

#### 5.2.2 转换方法

如前所述，**所有对象都具有toLocaleString()、toString()和valueOf()**方法。

***1. 转换方法***

调用数组的toString()方法：

会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。

- 实际上，为了创建这个字符串会调用数组每一项的toString()方法。

调用数组的toString()方法：

返回的还是数组。（是数组的字符串表示。返回对象的字符串、数值或布尔值表示。见3.4.7节）

```js
var colors = ["red", "blue", "green"]; // 创建一个包含3 个字符串的数组
alert(colors.toString()); // red,blue,green
alert(colors.valueOf()); // red,blue,green
alert(colors); // red,blue,green
```

- 最后一行代码直接将数组传递给了alert()。由于alert()要接收字符串参数，所以它会在后台调用toString()方法，由此会得到与直接调用toString()方法相同的结果。

调用数组的toLocaleString()方法：

经常也会返回与toString()和valueOf()方法相同的值，但也不总是如此。

- 当调用数组的toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的toLocaleString()方法，而不是toString()方法。

- ```js
  var person1 = {
  	toLocaleString : function () {
  		return "Nikolaos";
  	},
  	toString : function() {
  		return "Nicholas";
  	}
  };
  var person2 = {
  	toLocaleString : function () {
  		return "Grigorios";
  	},
  	toString : function() {
  		return "Greg";
  	}
  };
  var people = [person1, person2];
  alert(people); //Nicholas,Greg
  alert(people.toString()); //Nicholas,Greg
  alert(people.toLocaleString()); //Nikolaos,Grigorios
  ```

数组继承的toLocaleString()、toString()和valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。

调用数组的join()方法：

可以**使用不同的分隔符来构建这个字符串**。

```js
var colors = ["red", "green", "blue"];
alert(colors.join(",")); //red,green,blue
alert(colors.join("||")); //red||green||blue
```

- join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。

- 如果不给join()方法传入任何值，或者给它传入undefined，则使用逗号作为分隔符。

- - IE7 及更早版本会错误的使用字符串"undefined"作为分隔符。

如果数组中的某一项的值是null 或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以**空字符串**表示。

#### 5.2.3 栈方法

ECMAScript 数组也提供了一种让数组的行为类似于其他数据结构的方法。

***1. 栈***

栈是一种可以限制插入和删除项的数据结构；是一种**LIFO（Last-In-First-Out，后进先出）**的数据结构，也就是最新添加的项最早被移除。

***2. 实现栈的方法***

ECMAScript 为数组专门提供了push()和pop()方法，以便实现类似栈的行为。

- push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。

- pop()方法则从数组末尾移除最后一项，减少数组的length 值，然后返回移除的项。

  ```js
  var colors = new Array(); // 创建一个数组
  var count = colors.push("red", "green"); // 推入两项
  alert(count); //2
  count = colors.push("black"); // 推入另一项
  alert(count); //3
  var item = colors.pop(); // 取得最后一项
  alert(item); //"black"
  alert(colors.length); //2
  ```

***3. 栈方法与其他数组方法连用***

栈方法与其他数组方法连用

```js
var colors = ["red", "blue"];
colors.push("brown"); // 添加另一项
colors[3] = "black"; // 添加一项
alert(colors.length); // 4
var item = colors.pop(); // 取得最后一项
aler t(item); //"black"
```

#### 5.2.4 队列方法

***1. 队列***

队列数据结构的访问规则是**FIFO（First-In-First-Out，先进先出）**。队列在列表的末端添加项，从列表的前端移除项。

***2. 实现队列的方法***

结合使用shift()和push()方法，可以像使用队列一样使用数组。

- push()是向数组末端添加项的方法，并**返回**修改后数组的**长度**。

- shift()能够移除数组中的**第一个**项并**返回**该项，同时将数组长度减1。（shift /ʃɪft/ 改变）

  ```js
  var colors = new Array(); //创建一个数组
  var count = colors.push("red", "green"); //推入两项
  alert(count); //2
  count = colors.push("black"); //推入另一项
  alert(count); //3
  var item = colors.shift(); //取得第一项
  alert(item); //"red"
  alert(colors.length); //2
  ```

***3. unshift()与shift()区别***

ECMAScript 还为数组提供了一个unshift()方法。

- unshift()与shift()的用途相反：它能在数组前端添加任意个项并**返回**新数组的**长度**。

  ```js
  var colors = new Array(); //创建一个数组
  var count = colors.unshift("red", "green"); //推入两项
  alert(count); //2
  count = colors.unshift("black"); //推入另一项
  alert(count); //3
  var item = colors.pop(); //取得最后一项
  alert(item); //"green"
  alert(colors.length); //2
  ```

- IE7 及更早版本对JavaScript 的实现中存在一个偏差，其unshift()方法总是返回undefined 而不是数组的新长度。IE8 在非兼容模式下会返回正确的长度值。

#### 5.2.5 重排序方法

***1. 实现重排序的方法***

数组中已经存在两个可以直接用来重排序的方法：reverse()和sort()。

- reverse()方法会**反转**数组项的顺序。（reverse /rɪˈvɜ:s/ 反转）

  ```js
  var values = [1, 2, 3, 4, 5];
  values.reverse();
  alert(values); //5,4,3,2,1
  ```

- sort()方法按**升序**排列数组项——即最小的值位于最前面，最大的值排在最后面。（sort /sɔ:t/ 分类）

  ```js
  var values = [0, 1, 5, 10, 15];
  values.sort();
  alert(values); //0,1,10,15,5
  ```

  - sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。
  - 即使数组中的每一项都是数值，sort()方法比较的也是字符串

***2. Sort()的比较函数***

排序方式在很多情况下都不是最佳方案。因此sort()方法可以接收一个**比较函数作为参数**，以便我们指定哪个值位于哪个值的前面。

- 比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数

  - 这个比较函数可以适用于大多数数据类型，只要将其作为参数传递给sort()方法即可

  ```js
  function compare(value1, value2) {
  	if (value1 < value2) {
  		return -1;
  	} else if (value1 > value2) {
  		return 1;
  	} else {
  		return 0;
  	}
  }
  
  var values = [0, 1, 5, 10, 15];
  values.sort(compare);
  alert(values); //0,1,5,10,15
  ```

- 也可以通过比较函数产生**降序**排序的结果，只要交换比较函数返回的值即可

  ```js
  function compare(value1, value2) {
  	if (value1 < value2) {
  		return 1;
  	} else if (value1 > value2) {
  		return -1;
  	} else {
  		return 0;
  	}
  }
  
  var values = [0, 1, 5, 10, 15];
  values.sort(compare);
  alert(values); // 15,10,5,1,0
  ```

- 对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数

  ```js
  function compare(value1, value2){
  	return value2 - value1;
  }
  ```

- 由于比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果，因此减法操作就可以适当地处理所有这些情况。

#### 5.2.6 操作方法

***1. 操作方法***

ECMAScript 为操作已经包含在数组中的项提供了很多方法。

- concat()方法可以基于当前数组中的所有项创建一个新数组。（**concat /kɔ:ˈtait/ 连接**）

  ```js
  var colors = ["red", "green", "blue"];
  var colors2 = colors.concat("yellow", ["black", "brown"]);
  alert(colors); //red,green,blue
  alert(colors2); //red,green,blue,yellow,black,brown
  ```

  - 这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。
  - 如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。
  - 如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。

- slice()能够基于当前数组中的一或多个项创建一个新数组。（**slice /slaɪs/ 切下**）

  ```js
  var colors = ["red", "green", "blue", "yellow", "purple"];
  var colors2 = colors.slice(1);
  var colors3 = colors.slice(1,4);
  alert(colors2); //green,blue,yellow,purple
  alert(colors3); //green,blue,yellow
  ```

  - slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。
  - 在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。
  - 如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。
  - 不会影响原始数组。
  - 如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含5 项的数组上调用slice(-2,-1)与调用slice(3,4)得到的结果相同。
  - 如果结束位置小于起始位置，则返回空数组。

- splice()的主要用途是向数组的中部插入项。这个方法恐怕要算是最强大的数组方法了，它有很多种用法。（**splice /splaɪs/ 绞接，捻接(两段绳子)**)

  ```js
  var colors = ["red", "green", "blue"];
  var removed = colors.splice(0,1); // 删除第一项
  alert(colors); // green,blue
  alert(removed); // red，返回的数组中只包含一项
  
  removed = colors.splice(1, 0, "yellow", "orange"); // 从位置1 开始插入两项
  alert(colors); // green,yellow,orange,blue
  alert(removed); // 返回的是一个空数组
  
  removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项
  alert(colors); // green,red,purple,orange,blue
  alert(removed); // yellow，返回的数组中只包含一项
  ```

  - **删除**：可以删除任意数量的项，只需指定2 个参数：要删除的第一项的位置和要删除的项数。

  - - 例如，splice(0,2)会删除数组中的前两项。

  - **插入**：可以向指定位置插入任意数量的项，只需提供3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。

  - - 例如，splice(2,0,"red","green")会从当前数组的位置2 开始插入字符串"red"和"green"。

  - **替换**：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。

  - - 例如，splice      (2,1,"red","green")会删除当前数组位置2 的项，然后再从位置2 开始插入字符串"red"和"green"。

  - splice()方法**始终都会返回一个数组**，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。

#### 5.2.7 位置方法

***1. 位置方法***

ECMAScript 5 为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。

- indexOf()方法从数组的开头（位置0）开始向后查找。lastIndexOf()方法则从数组的末尾开始向前查找。

  ```js
  var numbers = [1,2,3,4,5,4,3,2,1];
  
  alert(numbers.indexOf(4)); //3
  alert(numbers.lastIndexOf(4)); //5
  
  alert(numbers.indexOf(4, 4)); //5
  alert(numbers.lastIndexOf(4, 4)); //3
  
  var person = { name: "Nicholas" };
  var people = [{ name: "Nicholas" }];
  var morePeople = [person];
  
  alert(people.indexOf(person)); //-1
  alert(morePeople.indexOf(person)); //0
  ```

  - 这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。
  - 这两个方法都返回要查找的**项在数组中的位置**，或者在没找到的情况下返回-1。
  - 在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用===一样）。

- 使用indexOf()和lastIndexOf()方法查找特定项在数组中的位置非常简单

- 支持它们的浏览器包括IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。

#### 5.2.8 迭代方法

***1. 迭代方法***

ECMAScript 5 为数组定义了5 个迭代方法。

- every()：对数组中的每一项运行给定函数，如果该函数对**每一项都返回true，则返回true**。

- filter()：对数组中的每一项运行给定函数，返回**该函数会返回true 的项组成的数组**。（**filter /ˈfɪltə(r)/ 过滤器**）

- forEach()：对数组中的每一项运行给定函数。这个方法**没有返回值**。

- map()：对数组中的每一项运行给定函数，返回**每次函数调用的结果组成的数组**。

- some()：对数组中的每一项运行给定函数，如果该函数对**任一项返回true，则返回true**。

- - 每个方法都接收两个参数：要在每一项上运行的**函数**和（可选的）运行该函数的作用域对象——影响this 的值。
  - 传入这些方法中的函数会接收三个参数：**数组项的值**、**该项在数组中的位置**和**数组对象本身**。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。
  - 都不会修改数组中的包含的值。

***2. 迭代方法用处***

- 最相似的是every()和some()，它们都用于**查询数组中的项是否满足某个条件**。

  ```js
  var numbers = [1,2,3,4,5,4,3,2,1];
  var everyResult = numbers.every(function(item, index, array){
  	return (item > 2);
  });
  alert(everyResult); //false
  
  var someResult = numbers.some(function(item, index, array){
  	return (item > 2);
  });
  alert(someResult); //true
  ```

- filter()利用指定的函数**确定是否在返回的数组中包含某一项**。

  ```js
  var numbers = [1,2,3,4,5,4,3,2,1];
  var filterResult = numbers.filter(function(item, index, array){
  	return (item > 2);
  });
  alert(filterResult); //[3,4,5,4,3]
  ```

- map()也**返回一个数组**，而这个**数组的每一项都是在原始数组中的对应项上运行传入函数的结果**。

  ```js
  var numbers = [1,2,3,4,5,4,3,2,1];
  var mapResult = numbers.map(function(item, index, array){
  	return item * 2;
  });
  alert(mapResult); //[2,4,6,8,10,8,6,4,2]
  ```

- forEach()是对数组中的**每一项运行传入的函数**。这个方法**没有返回值，本质上与使用for 循环迭代数组一样**。

  ```js
  var numbers = [1,2,3,4,5,4,3,2,1];
  numbers.forEach(function(item, index, array){
  	//执行某些操作
  });
  ```

这些数组方法通过执行不同的操作，可以大大方便处理数组的任务。

支持这些迭代方法的浏览器有IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。

#### 5.2.9 归并方法

***1. 归并方法***

ECMAScript 5 还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。

- reduce()方法从数组的第一项开始，逐个遍历到最后。（**reduce 减少**）

- reduceRight()则从数组的最后一项开始，向前遍历到第一项。

- - 一个在每一项上调用的函数和（可选的）作为归并基础的初始值。
  - 传给reduce()和reduceRight()的函数接收4 个参数：前一个值、当前值、项的索引和数组对象。
  - 这个函数返回的任何值都会作为第一个参数自动传给下一项。
  - 第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。

***2. 归并方法用处***

- 使用reduce()方法可以执行**求数组中所有值之和**的操作

  ```js
  var values = [1,2,3,4,5];
  var sum = values.reduce(function(prev, cur, index, array){
  	return prev + cur;
  });
  alert(sum); //15
  ```

- reduceRight()的作用类似，只不过方向相反而已

  ```js
  var values = [1,2,3,4,5];
  var sum = values.reduceRight(function(prev, cur, index, array){
  	return prev + cur;
  });
  alert(sum); //15
  ```

使用reduce()还是reduceRight()，主要取决于要从哪头开始遍历数组。除此之外，它们完全相同。

支持这两个归并函数的浏览器有IE9+、Firefox 3+、Safari 4+、Opera 10.5 和Chrome。

### 5.3 Date类型

***1. Date 类型***

ECMAScript 中的Date 类型是在早期Java 中的java.util.Date 类基础上构建的。为此，Date类型使用自**UTC**（Coordinated Universal Time，国际协调时间）**1970 年1 月1 日午夜（零时）开始经过的毫秒数来保存日期**。

***2. Date 对象***

创建一个日期对象，使用new 操作符和Date 构造函数

```js
var now = new Date();
```

- 无参，在调用Date 构造函数而不传递参数的情况下，新创建的对象自动获得**当前日期和时间**。
- 有参，如果想根据特定的日期和时间创建日期对象，**必须传入表示该日期的毫秒数**（即从UTC 时间1970 年1 月1 日午夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript 提供了两个方法：Date.parse()和Date.UTC()。

***3. 返回毫秒数***

Date.parse()（parse /pɑ:z/ （从语法上）分析）：接收一个表示日期的字符串参数，然后尝试根据这个字符串**返回相应日期的毫秒数**。

#### 5.3.1 继承的方法

与其他引用类型一样，Date 类型也重写了toLocaleString()、toString()和valueOf()方法；但这些方法返回的值与其他类型中的方法不同。

***1. 继承的方法***

- Date 类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM 或PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。

- Date 类型的toString()方法：则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0 到23）表示。

  - 下面给出了在不同浏览器中调用toLocaleString()和toString()方法，输出PST（Pacific Standard Time，太平洋标准时间）时间2007年2 月1 日午夜零时的结果。

    | 浏览器               | 方法                                                         |
    | -------------------- | ------------------------------------------------------------ |
    | Internet Explorer  8 | toLocaleString() —  Thursday, February 01, 2007 12:00:00 AM  toString() — Thu  Feb 1 00:00:00 PST 2007 |
    | Firefox 3.5          | toLocaleString() —  Thursday, February 01, 2007 12:00:00 AM  toString() — Thu  Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time) |
    | Safari 4             | toLocaleString() —  Thursday, February 01, 2007 00:00:00  toString() — Thu  Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time) |
    | Chrome 4             | toLocaleString() —  Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)  toString() — Thu  Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time) |
    | Opera 10             | toLocaleString() —  2/1/2007 12:00:00 AM  toString() — Thu,  01 Feb 2007 00:00:00 GMT-0800 |

  - 这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。这一差别仅在调试代码时比较有用，而在**显示日期和时间时没有什么价值**。

- Date 类型的valueOf()方法：则根本不返回字符串，而是返回日期的毫秒表示。因此，可以**方便使用比较操作符**（小于或大于）来比较日期值。

  ```js
  var date1 = new Date(2007, 0, 1); //"January 1, 2007"
  var date2 = new Date(2007, 1, 1); //"February 1, 2007"
  alert(date1 < date2); //true
  alert(date1 > date2); //false
  ```

#### 5.3.2 日期格式化方法

***1. 日期格式化方法***

Date 类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。

- toDateString()——以特定于实现的格式显示星期几、月、日和年；
- toTimeString()——以特定于实现的格式显示时、分、秒和时区；
- toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
- toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
- toUTCString()——以特定于实现的格式完整的UTC 日期。

与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。

除了前面介绍的方法之外，还有一个名叫toGMTString()的方法，这是一个与toUTCString()等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript 推荐现在编写的代码一律使用toUTCString()方法。

#### 5.3.3 日期/时间组件方法

***1. 日期/时间组件方法***

剩下还未介绍的Date 类型的方法（如下表所示），都是直接取得和设置日期值中特定部分的方法了。
注意：**UTC 日期指的是在没有时区偏差的情况下**（将日期转换为GMT 时间）的日期值。

| 方 法                    | 说 明                                                        |
| ------------------------ | ------------------------------------------------------------ |
| getTime()                | 返回表示日期的毫秒数；与valueOf()方法返回的值相同            |
| setTime(毫秒)            | 以毫秒数设置日期，会改变整个日期                             |
| getFullYear()            | 取得4位数的年份（如2007而非仅07）                            |
| getUTCFullYear()         | 返回UTC日期的4位数年份                                       |
| setFullYear(年)          | 设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）  |
| setUTCFullYear(年)       | 设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07） |
| getMonth()               | 返回日期中的月份，其中0表示一月，11表示十二月                |
| getUTCMonth()            | 返回UTC日期中的月份，其中0表示一月，11表示十二月             |
| setMonth(月)             | 设置日期的月份。传入的月份值必须大于0，超过11则增加年份      |
| setUTCMonth(月)          | 设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份   |
| getDate()                | 返回日期月份中的天数（1到31）                                |
| getUTCDate()             | 返回UTC日期月份中的天数（1到31）                             |
| setDate(日)              | 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 |
| setUTCDate(日)           | 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 |
| getDay()                 | 返回日期中星期的星期几（其中0表示星期日，6表示星期六）       |
| getUTCDay()              | 返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六）    |
| getHours()               | 返回日期中的小时数（0到23）                                  |
| getUTCHours()            | 返回UTC日期中的小时数（0到23）                               |
| setHours(时)             | 设置日期中的小时数。传入的值超过了23则增加月份中的天数       |
| setUTCHours(时)          | 设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数    |
| getMinutes()             | 返回日期中的分钟数（0到59）                                  |
| getUTCMinutes()          | 返回UTC日期中的分钟数（0到59）                               |
| setMinutes(分)           | 设置日期中的分钟数。传入的值超过59则增加小时数               |
| setUTCMinutes(分)        | 设置UTC日期中的分钟数。传入的值超过59则增加小时数            |
| getSeconds()             | 返回日期中的秒数（0到59）                                    |
| getUTCSeconds()          | 返回UTC日期中的秒数（0到59）                                 |
| setSeconds(秒)           | 设置日期中的秒数。传入的值超过了59会增加分钟数               |
| setUTCSeconds(秒)        | 设置UTC日期中的秒数。传入的值超过了59会增加分钟数            |
| getMilliseconds()        | 返回日期中的毫秒数                                           |
| getUTCMilliseconds()     | 返回UTC日期中的毫秒数                                        |
| setMilliseconds(毫秒)    | 设置日期中的毫秒数                                           |
| setUTCMilliseconds(毫秒) | 设置UTC日期中的毫秒数                                        |
| getTimezoneOffset()      | 返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某地进入夏令时的情况下，这个值会有所变化 |

### 5.4 RegExp类型

ECMAScript 通过RegExp 类型来支持正则表达式。（**regular /ˈregjələ(r)/ 有规则的**， **expression /ɪkˈspreʃn/ 表现、表达**）

***1. 定义正则表达式***

以字面量形式来定义的正则表达式：使用下面类似Perl 的语法，就可以创建一个正则表达式。

```js
var expression = / pattern / flags ;
```

- 模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。

- 每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。

- 正则表达式的匹配模式支持下列3 个标志。

  ```js
  /*
  * 匹配字符串中所有"at"的实例
  */
  var pattern1 = /at/g;
  /*
  * 匹配第一个"bat"或"cat"，不区分大小写
  */
  var pattern2 = /[bc]at/i;
  /*
  * 匹配所有以"at"结尾的3 个字符的组合，不区分大小写
  */
  var pattern3 = /.at/gi;
  ```

  - **g**：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
  - **i**：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
  - **m**：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

- 一个正则表达式就是1 个模式与上述3 个标志的组合体。

- 与其他语言中的正则表达式类似，模式中使用的所有**元字符**都必须转义。

  ```js
  /*
  * 匹配第一个"bat"或"cat"，不区分大小写
  */
  var pattern1 = /[bc]at/i;
  /*
  * 匹配第一个" [bc]at"，不区分大小写
  */
  var pattern2 = /\[bc\]at/i;
  /*
  * 匹配所有以"at"结尾的3 个字符的组合，不区分大小写
  */
  var pattern3 = /.at/gi;
  /*
  * 匹配所有".at"，不区分大小写
  */
  var pattern4 = /\.at/gi;
  ```

- - 正则表达式中的元字符包括：( [ { \ ^ $ | ) ? * + .]}（**14**=2+2+2+4+4）
  - 元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。

使用RegExp 构造函数来定义的正则表达式：使用RegExp 构造函数来创建正则表达式

```js
var expression = new RegExp();
```

- 它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。

- 注意传递给RegExp 构造函数的两个参数都是字符串（不能把正则表达式字面量传递给RegExp 构造函数）。

- 由于RegExp 构造函数的模式参数是字符串，所以在某些情况下要对字符进行**双重转义**。

- - 所有元字符都必须双重转义
  - 那些已经转义过的字符也是如此
  - 例如\n（字符\在字符串中通常被转义为\\，而在**正则表达式字符串**中就会变成\\\\）。

***2. 定义的区别***

可以使用字面量定义的任何表达式，都可以使用构造函数来定义

```js
/*
* 匹配第一个"bat"或"cat"，不区分大小写
*/
var pattern1 = /[bc]at/i;
/*
* 与pattern1 相同，只不过是使用构造函数创建的
*/
var pattern2 = new RegExp("[bc]at", "i");
```

下表给出了一些模式，左边是这些模式的字面量形式，右边是使用RegExp 构造函数定义相同模式时使用的字符串。

| 字面量模式       | 等价的字符串                                 |
| ---------------- | -------------------------------------------- |
| /\[bc\]at/       | "[\\[bc\\]at](file:///[bc/]at)"              |
| /\.at/           | "[\\.at](file:///.at)"                       |
| /name\/age/      | "name\\/age"                                 |
| /\d.\d{1,2}/     | "[\\d.\\d{1,2}](file:///d./d{1,2})"          |
| /\w\\hello\\123/ | "[\\w\\\\hello\\\\123](file:///w/hello/123)" |

***3. 创建正则表达式的区别***

使用正则表达式字面量和使用RegExp 构造函数创建的正则表达式不一样。

```js
var re = null,
	i;
for (i=0; i < 10; i++){
	re = /cat/g;
	re.test("catastrophe");
}
for (i=0; i < 10; i++){
	re = new RegExp("cat", "g");
	re.test("catastrophe");
}
```

- 在ECMAScript 3 中，正则表达式字面量始终会共享同一个**RegExp 实例**，而使用构造函数创建的每一个新RegExp 实例都是一个新实例。

- 第一个循环中，即使是循环体中指定的，但实际上只为/cat/创建了一个RegExp 实例。

- - 由于实例属性（下一节介绍实例属性）不会重置，所以在循环中再次调用test()方法会失败。
  - 这是因为第一次调用test()找到了"cat"，但第二次调用是从索引为3 的字符（上一次匹配的末尾）开始的，所以就找不到它了。由于会测试到字符串末尾，所以下一次再调用test()就又从开头开始了。

- 第二个循环使用RegExp 构造函数在每次循环中创建正则表达式。

- - 因为每次迭代都会创建一个新的RegExp 实例，所以每次调用test()都会返回true。

- ECMAScript 5 明确规定，使用正则表达式字面量必须像直接调用RegExp 构造函数一样，每次都创建新的RegExp 实例。IE9+、Firefox 4+和Chrome 都据此做出了修改。

#### 5.4.1 RegExp实例属性

***1. RegExp实例属性***

RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。

- global：布尔值，表示是否设置了g 标志。
- ignoreCase：布尔值，表示是否设置了i 标志。（**ignore /[ɪgˈnɔ:(r)/ 忽略**）
- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0 算起。
- multiline：布尔值，表示是否设置了m 标志。（**multiline /'mʌltɪlɪn/ 多线路的**）
- source：正则表达式的字符串表示，按照**字面量形式**而非传入**构造函数中的字符串模式**返回。
  - 它们的source 属性是相同的。可见，source 属性保存的是**规范形式的字符串，即字面量形式所用的字符串**。

这些属性可以获知一个正则表达式的各方面信息，但却**没有多大用处**，因为这些信息全都包含在模式声明中。

```js
var pattern1 = /\[bc\]at/i;
alert(pattern1.global); //false
alert(pattern1.ignoreCase); //true
alert(pattern1.multiline); //false
alert(pattern1.lastIndex); //0
alert(pattern1.source); //"\[bc\]at"

var pattern2 = new RegExp("\\[bc\\]at", "i");
alert(pattern2.global); //false
alert(pattern2.ignoreCase); //true
alert(pattern2.multiline); //false
alert(pattern2.lastIndex); //0
aler t(pattern2.source); //"\[bc\]at"
```

#### 5.4.2 RegExp实例方法

***1. exec()***

RegExp 对象的主要方法是exec()，该方法是专门为**捕获组**而设计的。（**exec /ɪgˈzek/ 实行**）(字符组、捕获组（带小括号）、非捕获组（防止作为捕获组，降低内存占用）)

- exec()接受一个参数，即要应用模式的字符串

- 返回包含**第一个匹配项信息的数组**；或者在没有匹配项的情况下返回**null**。

- 返回的数组虽然是Array 的实例，但包含两个额外的属性：**index** 和**input**。

- - index      表示匹配项在字符串中的位置
  - input      表示应用正则表达式的字符串

- 在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。

- 对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。

- - 在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回**第一个**匹配项的信息。
  - 在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找**新**匹配项的信息。

示例：

```js
var text = "mom and dad and baby";
var pattern = /mom( and dad( and baby)?)?/gi;

var matches = pattern.exec(text);
alert(matches.index); // 0
alert(matches.input); // "mom and dad and baby"
alert(matches[0]); // "mom and dad and baby"
alert(matches[1]); // " and dad and baby"
alert(matches[2]); // " and baby"
```

- 这个例子中的模式包含两个捕获组

- - 第一捕获组：最内部的捕获组匹配"and baby"，
  - 第二捕获组：而包含它的捕获组匹配**"and dad"**或者**"and dad and baby**"。

- 当把字符串传入exec()方法中之后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组matchs 的index 属性值为0。

- 数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。

```js
var text = "cat, bat, sat, fat";
var pattern1 = /.at/;

var matches = pattern1.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern1.lastIndex); //0

matches = pattern1.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern1.lastIndex); //0

var pattern2 = /.at/g;

var matches = pattern2.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern2.lastIndex); //3

matches = pattern2.exec(text);
alert(matches.index); //5
alert(matches[0]); //bat
alert(pattern2.lastIndex); //8
```

- 第一个模式pattern1 不是全局模式，因此每次调用exec()返回的都是第一个匹配项（"cat"）。
- 第二个模式pattern2 是全局模式，因此每次调用exec()都会返回字符串中的下一个匹配项，直至搜索到字符串末尾为止。
- 此外，还应该注意模式的lastIndex 属性的变化情况。在全局匹配模式下，lastIndex 的值在每次调用exec()后都会增加，而在非全局模式下则始终保持不变。
- IE 的JavaScript 实现在lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex 属性每次也会变化。

***2. test()***

正则表达式的第二个方法是test()，

- 它接受一个字符串参数。在模式与该参数**匹配的情况下返回true**；否则，返回false。
- 在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此，test()方法经常被用在if 语句中

```js
var text = "000-00-0000";
var pattern = /\d{3}-\d{2}-\d{4}/;

if (pattern.test(text)){
	alert("The pattern was matched.");
}
```

- 在这个例子中，我们使用正则表达式来测试了一个数字序列。如果输入的文本与模式匹配，则显示一条消息。这种用法经常出现在验证用户输入的情况下，因为我们只想知道输入是不是有效，至于它为什么无效就无关紧要了。

***3. 继承的方法***

RegExp 实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。

```js
var pattern = new RegExp("\\[bc\\]at", "gi");
alert(pattern.toString()); // /\[bc\]at/gi
alert(pattern.toLocaleString()); // /\[bc\]at/gi
```

正则表达式的valueOf()方法返回正则表达式本身。

#### 5.4.3 RegExp构造函数属性

***1. RegExp构造函数属性***

RegExp 构造函数包含一些属性（这些属性在其他语言中被看成是**静态属性**）。

- 这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。

- 关于这些属性的另一个独特之处，就是可以通过两种方式访问它们：一个长属性名和一个短属性名（Opera 是例外，它不支持短属性名）

使用这些属性可以从exec()或test()执行的操作中提取出更具体的信息。

| 长属性名     | 短属性名 | 说 明                                                        |
| ------------ | -------- | ------------------------------------------------------------ |
| input        | $_       | 最近一次要匹配的字符串。Opera未实现此属性                    |
| lastMatch    | $&       | 最近一次的匹配项。Opera未实现此属性                          |
| lastParen    | $+       | 最近一次匹配的捕获组。Opera未实现此属性                      |
| leftContext  | $`       | input字符串中lastMatch之前的文本                             |
| multiline    | $*       | 布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性 |
| rightContext | $'       | Input字符串中lastMatch之后的文本                             |

（**Match /mætʃ/ 比赛**, **Paren /'pəren/ 括号**）

***2. 属性的使用***

直接使用长属性名

```js
var text = "this has been a short summer";
var pattern = /(.)hort/g;
/*
* 注意：Opera 不支持input、lastMatch、lastParen 和multiline 属性
* Internet Explorer 不支持multiline 属性
*/
if (pattern.test(text)){
	alert(RegExp.input); // this has been a short summer
	alert(RegExp.leftContext); // this has been a
	alert(RegExp.rightContext); // summer
	alert(RegExp.lastMatch); // short
	alert(RegExp.lastParen); // s
	alert(RegExp.multiline); // false
}
```

- 以上代码创建了一个模式，匹配任何一个字符后跟hort，而且把第一个字符放在了一个捕获组中。

- RegExp 构造函数的各个属性返回了下列值：

- - input 属性返回了原始字符串；
  - leftContext 属性返回了单词short 之前的字符串，而rightContext 属性则返回了short
  - 之后的字符串；
  - lastMatch 属性返回**最近一次与整个正则表达式匹配的字符串**，即short；（**理解：捕获组**）
  - lastParen 属性返回最近一次匹配的捕获组，即例子中的s。

长属性名都可以用相应的短属性名来代替。

```js
var text = "this has been a short summer";
var pattern = /(.)hort/g;
/*
* 注意：Opera 不支持input、lastMatch、lastParen 和multiline 属性
* Internet Explorer 不支持multiline 属性
*/
if (pattern.test(text)){
	alert(RegExp.$_); // this has been a short summer
	alert(RegExp["$`"]); // this has been a
	alert(RegExp["$'"]); // summer
	alert(RegExp["$&"]); // short
	alert(RegExp["$+"]); // s
	alert(RegExp["$*"]); // false
}
```

- 只不过，由于这些短属性名大都不是有效的ECMAScript 标识符，因此必须通过方括号语法来访问它们

***3. 其他属性***

除了上面介绍的几个属性之外，还有多达9 个用于存储捕获组的构造函数属性。

- 访问这些属性的语法是RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。
- 在调用exec()或test()方法时，这些属性会被自动填充。然后，我们就可以像下面这样来使用它们。

示例：

```js
var text = "this has been a short summer";
var pattern = /(..)or(.)/g;
if (pattern.test(text)){
	alert(RegExp.$1); //sh
	alert(RegExp.$2); //t
}
```

- 这里创建了一个包含两个捕获组的模式，并用该模式测试了一个字符串。
- 即使test()方法只返回一个布尔值，但RegExp 构造函数的属性$1 和$2 也会被匹配相应捕获组的字符串自动填充。

#### 5.4.4 模式的局限性

***1.局限性***

尽管ECMAScript 中的正则表达式功能还是比较完备的，但仍然**缺少某些语言（特别是Perl）所支持的高级正则表达式特性**。（要了解更多相关信息，请访问www.regular-expressions.info）。

- 匹配字符串开始和结尾的\A 和\Z 锚【但支持以插入符号（^）和美元符号（$）来匹配字符串的开始和结尾。】
- 向后查找（lookbehind）【但完全支持向前查找（lookahead）。】
- 并集和交集类
- 原子组（atomic grouping）
- Unicode 支持【单个字符除外，如\uFFFF】
- 命名的捕获组（但支持编号的捕获组。）
- s（single，单行）和x（free-spacing，无间隔）匹配模式
- 条件匹配
- 正则表达式注释

即使存在这些限制，ECMAScript 正则表达式仍然是非常强大的，能够帮我们完成绝大多数模式匹配任务。

### 5.5 Function类型

***1.函数是对象***

说起来ECMAScript 中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于**函数实际上是对象**。

- 由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。
- 每个函数都是Function 类型的实例，而且都与其他引用类型一样具有属性和方法。

***2. 三种定义方式***

- 函数通常是使用**函数声明**语法定义

  ```js
  function sum (num1, num2) {
  	return num1 + num2;
  }
  ```

- 还可以使用**函数表达式**定义

  ```js
  var sum = function(num1, num2){
  	return num1 + num2;
  };
  ```
  - 定义了变量sum 并将其初始化为一个函数。
  - function 关键字后面没有函数名。这是因为在使用函数表达式定义函数时，没有必要使用函数名——通过变量sum 即可以引用函数。
  - 还要注意函数末尾有一个分号，就像声明其他变量时一样。

- 两种方法几乎相差无几。

- 最后还可以使用**Function 构造函数**定义

  ```js
  var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
  ```

  - Function 构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。
  - 从技术角度讲，这是一个函数表达式。
  - 不推荐读者使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。
  - 不过，这种语法对于**理解“函数是对象，函数名是指针”的概念**倒是非常直观的。

***3. 函数名与对象变量***

由于**函数名仅仅是指向函数的指针**，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，**一个函数可能会有多个名字**

```js
function sum(num1, num2){
	return num1 + num2;
}
alert(sum(10,10)); //20

var anotherSum = sum;
alert(anotherSum(10,10)); //20

sum = null;
alert(anotherSum(10,10)); //20
```

- 注意，使用**不带圆括号的函数名是访问函数指针，而非调用函数**。此时，anotherSum 和sum 就都指向了同一个函数，因此anotherSum()也可以被调用并返回结果。
- 即使将sum 设置为null，让它与函数“断绝关系”，但仍然可以正常调用anotherSum()。

#### 5.5.1 没有重载（深入理解）

***1. 没有重载***

将**函数名想象为指针**，也**有助于理解为什么ECMAScript 中没有函数重载**的概念

```js
function addSomeNumber(num){
	return num + 100;
}

function addSomeNumber(num) {
	return num + 200;
}

var result = addSomeNumber(100); //300
```

- 两个同名函数，结果则是后面的函数覆盖了前面的函数。

  ```js
  var addSomeNumber = function (num){
  	return num + 100;
  };
  
  addSomeNumber = function (num) {
  	return num + 200;
  };
  
  var result = addSomeNumber(100); //300
  ```

- 在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber。

#### 5.5.2 函数声明与函数表达式

***1. 函数声明与函数表达式的区别***

实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。

- 解析器会**率先读取函数声明**，并使其在执行任何代码之前可用（可以访问）

  ```js
  alert(sum(10,10));
  function sum(num1, num2){
  	return num1 + num2;
  }
  ```

  - 以上代码完全可以正常运行。

  - 因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。

- 至于函数表达式，则必须等到解析器**执行到它所在的代码行，才会真正被解释执行**

  ```js
  alert(sum(10,10));
  var sum = function(num1, num2){
  	return num1 + num2;
  };
  ```

  - 以上代码之所以会在运行期间产生错误
  - 原因在于函数位于一个初始化语句中，而不是一个函数声明。换句话说，在执行到函数所在的语句之前，变量sum 中不会保存有对函数的引用；而且，由于第一行代码就会导致“unexpected identifier”（意外标识符）错误，实际上也不会执行到下一行。

除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。

也可以同时使用函数声明和函数表达式，例如var sum = function sum(){}。不过，这种语法在Safari 中会导致错误。

#### 5.5.3 作为值的函数

***1. 函数作为值来使用***

因为ECMAScript 中的**函数名本身就是变量**，所以函数也可以**作为值来使用**。

- 可以像传递参数一样**把一个函数传递给另一个函数**

  ```js
  function callSomeFunction(someFunction, someArgument){
  	return someFunction(someArgument);
  }
  ```

  - 第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。

- 然后，就可以像下面的例子一样传递函数了。

  ```js
  function add10(num){
  	return num + 10;
  }
  
  var result1 = callSomeFunction(add10, 10);
  alert(result1); //20
  
  function getGreeting(name){
  	return "Hello, " + name;
  }
  
  var result2 = callSomeFunction(getGreeting, "Nicholas");
  alert(result2); //"Hello, Nicholas"
  ```

  - 这里的callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。
  - 还记得吧，要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。

- 可以**将一个函数作为另一个函数的结果**返回。

  ```js
  function createComparisonFunction(propertyName) {
  	return function(object1, object2){
  		var value1 = object1[propertyName];
  		var value2 = object2[propertyName];
  		
  		if (value1 < value2){
  			return -1;
  		} else if (value1 > value2){
  			return 1;
  		} else {
  			return 0;
  		}
  	};
  }
  ```

  - 从一个函数中返回另一个函数，这也是**极为有用的一种技术**。

  - 例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。

    ```js
    var data = [{name: "Zachary", age: 28}, {name: "Nicholas", age: 29}];
    
    data.sort(createComparisonFunction("name"));
    alert(data[0].name); //Nicholas
    
    data.sort(createComparisonFunction("age"));
    alert(data[0].name); //Zachary
    ```

    - 而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。
    - 可是，我们需要一种方式来指明按照哪个属性来排序。
    - 要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数

#### 5.5.4 函数内部属性

在函数内部，有两个特殊的对象：arguments 和this。（**arguments /'ɑ:ɡjʊmənts/论据; 争吵**）

***1. arguments***

arguments 在第3 章曾经介绍过，它是一个**类数组对象**，包含着传入函数中的所有参数。

```js
function factorial(num){
	if (num <=1) {
		return 1;
	} else {
		return num * factorial(num-1)
	}
}
```

- 定义阶乘函数一般都要用到递归算法；
- 在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。
- 但问题是这个函数的执行与函数名factorial 紧紧耦合在了一起。

消除紧密耦合的现象，可以像下面这样使用arguments.callee（解耦合）。（**callee /kɔ:'li:/ 被召者; 受话人**）

- 虽然arguments 的主要用途是保存函数参数，但这个对象还有一个名叫**callee 的属性**该属性**是一个指针，指向拥有这个arguments 对象的函数**。

- 请看下面这个非常经典的阶乘函数：

  ```js
  function factorial(num){
  	if (num <=1) {
  		return 1;
  	} else {
  		return num * arguments.callee(num-1)
  	}
  }
  ```

- 这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。

  ```js
  var trueFactorial = factorial;
  
  factorial = function(){
  	return 0;
  };
  
  alert(trueFactorial(5)); //120
  aler t(factorial(5)); //0
  ```

***2. this***

this函数内部的另一个特殊对象，其行为与Java 和C#中的this 大致类似。换句话说，this引用的是函数据以**执行的环境对象**——或者也可以说是this 值（当在网页的全局作用域中调用函数时，this 对象引用的就是window）。

```js
window.color = "red";
var o = { color: "blue" };

function sayColor(){
	alert(this.color);
}

sayColor(); //"red"

o.sayColor = sayColor;
o.sayColor(); //"blue"
```

- 这个函数sayColor()是在全局作用域中定义的，它引用了this 对象。
- 由于**在调用函数之前，this的值并不确定**，因此this 可能**会在代码执行过程中引用不同的对象**。

***3. caller***

ECMAScript 5 也规范化了另一个函数对象。函数对象的属性：caller。(**caller /ˈkɔ:lə(r)/ 呼叫者; 召集者;**)

- 这个属性中保存着**调用当前函数的函数的引用**，如果是在全局作用域中调用当前函数，它的值为null。

  ```js
  function outer(){
  	inner();
  }
  
  function inner(){
  	alert(inner.caller);
  }
  
  outer();
  ```

  - 除了Opera 的早期版本不支持，其他浏览器都支持这个ECMAScript 3 并没有定义的属性。

  - 以上代码会导致警告框中显示outer()函数的源代码。

  - 为了实现**解耦合**，也可以通过**arguments.callee.caller**来访问相同的信息。

    ```js
    function outer(){
    	inner();
    }
    
    function inner(){
    	alert(arguments.callee.caller);
    }
    
    outer();
    ```

  - IE、Firefox、Chrome 和Safari 的所有版本以及Opera 9.6 都支持caller 属性。

严格模式下：

- 当函数在严格模式下运行时，访问arguments.callee 会导致错误。

- ECMAScript 5 还定义了arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。

- - 定义这个属性是为了分清arguments.caller 和函数的caller 属性。

- 以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。

- 严格模式还有一个限制：不能为函数的caller 属性赋值，否则会导致错误。

#### 5.5.5 函数属性和方法

***1. 属性***

ECMAScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length 和prototype。

- length 属性表示函数希望接收的命名参数的个数

  ```js
  function sayName(name){
  	alert(name);
  }
  
  function sum(num1, num2){
  	return num1 + num2;
  }
  
  function sayHi(){
  	alert("hi");
  }
  
  alert(sayName.length); //1
  alert(sum.length); //2
  alert(sayHi.length); //0
  ```

- 在ECMAScript 核心所定义的全部属性中，**最耐人寻味的就要数prototype 属性**了。

  - 对于ECMAScript 中的引用类型而言，prototype 是**保存它们所有实例方法**的真正所在。
  - 换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype 名下，只不过是通过各自**对象的实例访问**罢了。
  - 在创建自定义引用类型以及实现**继承**时，prototype 属性的作用是极为重要的（第6 章将详细介绍）。
  - 在ECMAScript 5 中，p**rototype 属性是不可枚举**的，因此使用**for-in 无法发现**。

***2. 方法***

每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是**在特定的作用域中调用函数**，实际上等于**设置函数体内this 对象的值**。

apply()方法：(**apply 申请**)

```js
function sum(num1, num2){
	return num1 + num2;
}

function callSum1(num1, num2){
	return sum.apply(this, arguments); // 传入arguments 对象
}

function callSum2(num1, num2){
	return sum.apply(this, [num1, num2]); // 传入数组
}

alert(callSum1(10,10)); //20
alert(callSum2(10,10)); //20
```

- 接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array 的实例，也可以是arguments 对象。
- callSum1()在执行sum()函数时传入了this 作为this 值（因为是在全局作用域中调用的，所以传入的就是window 对象）和arguments 对象。

call()方法：

```js
function sum(num1, num2){
	return num1 + num2;
}

function callSum(num1, num2){
	return sum.call(this, num1, num2);
}

alert(callSum(10,10)); //20
```

- 与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言：
  - 第一个参数是this 值没有变化，变化的是**其余参数都直接传递给函数**。
  - 换句话说，在使用call()方法时，传递给函数的参数必须**逐个列举出来**

apply()或call()：

- 至于是使用apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。

- - 如果你打算直接传入arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用apply()肯定更方便；
  - 否则，选择call()可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓。）

- 事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够**扩充函数赖以运行的作用域**。

  ```js
  window.color = "red";
  var o = { color: "blue" };
  
  function sayColor(){
  	alert(this.color);
  }
  
  sayColor(); //red
  
  sayColor.call(this); //red
  sayColor.call(window); //red
  sayColor.call(o); //blue
  ```

  - 这个例子是在前面说明this 对象的示例基础上修改而成的。

  - **使用call()（或apply()）来扩充作用域的最大好处**，就是**对象不需要与方法有任何耦合关系**。

  - 在前面例子的第一个版本中，我们是先将sayColor()函数放到了对象o 中，然后再通过o 来调用它的；而在这里重写的例子中，就不需要先前那个多余的步骤了。（见5.5.4）

ECMAScript 5 还定义了一个方法：bind()：

```js
window.color = "red";
var o = { color: "blue" };

function sayColor(){
	alert(this.color);
}

var objectSayColor = sayColor.bind(o);
objectSayColor(); //blue
```

这个方法会**创建一个函数的实例**，其this 值会被绑定到传给bind()函数的值。（**bind 绑定**）

- sayColor()调用bind()并传入对象o，创建了objectSayColor()函数。objectSayColor()函数的this 值等于o，因此即使是在全局作用域中调用这个函数，也会看到"blue"。**这种技巧的优点请参考第22 章**。（？）
- 支持bind()方法的浏览器有IE9+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。

***3. 继承方法***

- 每个函数继承的toLocaleString()和toString()方法始终都返回函数的代码。

- - 返回代码的格式则因浏览器而异

  - - 有的返回的代码与源代码中的函数代码一样，
    - 而有的则返回函数代码的内部表示，即由解析器删除了注释并对某些代码作了改动后的代码。

  - 由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；

  - 不过，这些信息在调试代码时倒是很有用。

- 另外一个继承的valueOf()方法同样也只返回函数代码。

### 5.6 基本包装类型

***1. 三个包装类型***

为了便于操作基本类型值，ECMAScript 还提供了3 个特殊的引用类型：Boolean、Number 和String。

- 这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。

***2. 自动创建***

实际上，每当读取一个基本类型值的时候，后台就会**创建**一个对应的基本包装类型的对象，从而让我们**能够调用一些方法来操作这些数据**。

```js
var s1 = "some text";
var s2 = s1.substring(2);
```

- 变量s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了s1 的substring()方法，并将返回的结果保存在了s2 中。

我们知道，**基本类型值不是对象**，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，后台已经**自动完成了一系列的处理**。

当第二行代码访问s1 时，访问过程处于一种**读取模式**，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。

- (1) 创建String 类型的一个实例；
- (2) 在实例上调用指定的方法；
- (3) 销毁这个实例。

***3. 引用类型与基本包装类型***

引用类型与基本包装类型的主要区别就是对象的生存期。

- 使用new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。
- 而自动创建的基本包装类型的对象，则**只存在于一行代码的执行瞬间**，然后立即被销毁。这意味着我们**不能在运行时为基本类型值添加属性和方法**。

```js
var s1 = "some text";
s1.color = "red";
alert(s1.color); //undefined
```

***4. 显式创建***

可以显式地调用Boolean、Number 和String 来创建基本包装类型的对象。

- 不过，应该在绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。

- 对基本包装类型的实例调用typeof 会返回"object"，而且所有基本包装类型的对象都会被转换为布尔值true。

- Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。

  ```js
  var obj = new Object("some text");
  alert(obj instanceof String); //true
  ```

  - 把字符串传给Object 构造函数，就会创建String 的实例；
  - 而传入数值参数会得到Number 的实例，传入布尔值参数就会得到Boolean 的实例。

- 注意：使用new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。

  ```js
  var value = "25";
  var number = Number(value); //转型函数
  alert(typeof number); //"number"
  
  var obj = new Number(value); //构造函数
  alert(typeof obj); //"object"
  ```

  - 变量number 中保存的是基本类型的值25，而变量obj 中保存的是Number 的实例。（要了解有关转型函数的更多信息，请参考第3 章。）

尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。而每个基本包装类型都提供了操作相应值的便捷方法。

#### 5.6.1 Boolean类型

Boolean 类型是**与布尔值对应**的引用类型。

***1. Boolean 对象***

要创建Boolean 对象，可以像下面这样调用Boolean构造函数并传入true 或false 值。

```js
var booleanObject = new Boolean(true);
```

- Boolean 类型的实例重写了valueOf()方法，返回基本类型值true 或false；
- 重写了toString()方法，返回字符串"true"和"false"。（不像其他对象返回字符串）

***2. Boolean 对象造成误解***

Boolean 对象在ECMAScript 中的用处不大，因为它经常会造成人们的误解。其中最常见的问题就是**在布尔表达式中使用Boolean 对象**

```js
var falseObject = new Boolean(false);
var result = falseObject && true;
alert(result); //true

var falseValue = false;
result = falseValue && true;
alert(result); //false
```

- 对falseObject 而不是对它的值（false）进行求值。
- 前面讨论过，**布尔表达式**中的**所有对象都会被转换为true**，因此falseObject 对象在布尔表达式中代表的是true。结果，true && true 当然就等于true 了。

基本类型与引用类型的布尔值还有两个区别。

```js
alert(typeof falseObject); //object
alert(typeof falseValue); //boolean
alert(falseObject instanceof Boolean); //true
alert(falseValue instanceof Boolean); //false
```

- typeof 操作符对基本类型返回"boolean"，而对引用类型返回"object"。
- 由于Boolean 对象是Boolean 类型的实例，所以使用instanceof 操作符测试Boolean 对象会返回true，而测试基本类型的布尔值则返回false。

**理解基本类型的布尔值与Boolean 对象之间的区别非常重要**，当然，我们的建议是**永远不要使用Boolean 对象**。

#### 5.6.2 Number类型

Number 是**与数字值对应**的引用类型。

***1. Number 对象***

要创建Number 对象，可以在调用Number 构造函数时向其中传递相应的数值。

```js
var numberObject = new Number(10);
```

***2. 继承方法***

- 与Boolean 类型一样，Number 类型也重写了valueOf()、toLocaleString()和toString()方法。

- 重写后的valueOf()方法**返回对象**表示的基本类型的数值，另外两个方法则**返回字符串**形式的数值。

- 与Boolean 类型一样，Number 类型也重写了valueOf()、toLocaleString()和toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。

  ```js
  var num = 10;
  alert(num.toString()); //"10"
  alert(num.toString(2)); //"1010"
  alert(num.toString(8)); //"12"
  alert(num.toString(10)); //"10"
  alert(num.toString(16)); //"a"
  ```

***3. 非继承方法***

除了继承的方法之外，Number 类型还提供了一些用于将数值格式化为字符串的方法。

toFixed()方法：

```js
var num = 10;
alert(num.toFixed(2)); //"10.00"
```

- 会按照指定的小数位返回数值的字符串表示（**Fixed /fɪkst/ 固定的**）

- 舍入

  ```js
  var num = 10.005;
  alert(num.toFixed(2)); //"10.01"
  ```

  - 注意的是，不同浏览器给这个方法设定的舍入规则可能会有所不同。在给toFixed()传入0 的情况下，IE8 及之前版本不能正确舍入范围在{(-0.94,-0.5],[0.5,0.94)}之间的值。对于这个范围内的值，IE 会返回0，而不是-1 或1；其他浏览器都能返回正确的值。IE9 修复了这个问题。

- 可以表示带有0 到20 个小数位的数值。但这只是标准实现的范围，有些浏览器也可能支持更多位数。

toExponential()方法：

```js
var num = 10;
alert(num.toExponential(1)); //"1.0e+1"
```

- 返回以指数表示法（也称e 表示法）表示的数值的字符串形式。（**Exponential /ˌekspəˈnenʃl/ 指数**）

toPrecision()方法：

```js
var num = 99;
alert(num.toPrecision(1)); //"1e+2"
alert(num.toPrecision(2)); //"99"
aler t(num.toPrecision(3)); //"99.0"
```

- 返回表示某个数值的最合适的格式。（**Precision /prɪˈsɪʒn/ 精确度**）
- 可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式；具体规则是看哪种格式最合适。
- 这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。
- 实际上，toPrecision()会根据要处理的数值决定到底是调用toFixed()还是调用toExponential()。
- 而这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值。
- toPrecision()方法可以表现1 到21 位小数。某些浏览器支持的范围更大，但这是典型实现的范围。

***4. 自动创建***

与Boolean 对象类似，Number 对象也以后台方式为数值提供了重要的功能。

但与此同时，我们仍然不建议直接实例化Number 类型，而原因与显式创Boolean 对象一样。

- 具体来讲，就是在使用typeof 和instanceof 操作符测试基本类型数值与引用类型数值时，得到的结果完全不同

  ```js
  var numberObject = new Number(10);
  var numberValue = 10;
  alert(typeof numberObject); //"object"
  alert(typeof numberValue); //"number"
  alert(numberObject instanceof Number); //true
  aler t(numberValue instanceof Number); //false
  ```
  - 在使用typeof 操作符测试基本类型数值时，始终会返回"number"，而在测试Number 对象时，则会返回"object"。类似地，Number 对象是Number 类型的实例，而基本类型的数值则不是

#### 5.6.3 String类型

String 类型是**字符串**的**对象包装类型**

***1. String 对象***

使用String 构造函数来创建。

```js
var stringObject = new String("hello world");
```

***2. 继承方法***

String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的valueOf()、toLocaleString()和toString()方法，都返回对象所表示的**基本字符串值**。（**区前边两个基本包装类**）

***3. 属性***

length 属性，表示字符串中包含多个字符。

```js
var stringValue = "hello world";
alert(stringValue.length); //"11"
```

- 输出了字符串"hello world"中的字符数量，即"11"。
- 注意：即使字符串中包含双字节字符（不是占一个字节的ASCII 字符），每个字符也**仍然算一个字符**。

***4. 非继承的方法***

String 类型提供了很多方法，用于辅助完成对ECMAScript 中字符串的**解析和操作**。

**字符方法**：

两个用于访问字符串中特定字符的方法是：charAt()和charCodeAt()。这两个方法都接收一个参数，即**基于0 的字符位置**。

- charAt()方法以单字符字符串的形式返回给定位置的那个字符（ECMAScript 中没有字符类型）。

  ```js
  var stringValue = "hello world";
  alert(stringValue.charAt(1)); //"e"
  ```

- charCodeAt()方法以字符编码的形式返回给定位置的那个字符

  ```js
  var stringValue = "hello world";
  alert(stringValue.charCodeAt(1)); //输出"101"
  ```

- ECMAScript 5 还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用**方括号加数字索引**来访问字符串中的特定字符

  ```js
  var stringValue = "hello world";
  alert(stringValue[1]); //"e"
  ```

  - 使用方括号表示法访问个别字符的语法得到了IE8 及Firefox、Safari、Chrome 和Opera 所有版本的支持。如果是在IE7 及更早版本中使用这种语法，会返回undefined 值（尽管根本不是特殊的undefined 值）。

**字符串操作方法**：

- concat()方法用于将一或多个字符串拼接起来，返回拼接得到的新字符串。

  ```js
  var stringValue = "hello ";
  var result = stringValue.concat("world");
  alert(result); //"hello world"
  alert(stringValue); //"hello"
  ```

  - 实际上，concat()方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串。

    ```js
    var stringValue = "hello ";
    var result = stringValue.concat("world", "!");
    alert(result); //"hello world!"
    alert(stringValue); //"hello"
    ```

  - 虽然concat()是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符（+）。

- slice()、substr()和substring()方法，ECMAScript 提供的三个基于**子字符串创建新字符串**的方法。

  - 都会返回被操作字符串的一个子字符串

  - 都接受一或两个参数

  - - 第一个参数指定子字符串的开始位置，

    - 第二个参数（在指定的情况下）表示子字符串到哪里结束。

    - - slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。
      - substr()的第二个参数指定的则是返回的字符个数。

    - 如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。

  - 与concat()方法一样，slice()、substr()和substring()也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。

    ```js
    var stringValue = "hello world";
    alert(stringValue.slice(3)); //"lo world"
    alert(stringValue.substring(3)); //"lo world"
    alert(stringValue.substr(3)); //"lo world"
    alert(stringValue.slice(3, 7)); //"lo w"
    alert(stringValue.substring(3,7)); //"lo w"
    alert(stringValue.substr(3, 7)); //"lo worl"
    ```

  - 在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。

    - slice()方法会将传入的负值与字符串的长度相加，
    - substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。
    - substring()方法会把所有负值参数都转换为0。

    ```js
    var stringValue = "hello world";
    alert(stringValue.slice(-3)); //"rld"
    alert(stringValue.substring(-3)); //"hello world"
    alert(stringValue.substr(-3)); //"rld"
    alert(stringValue.slice(3, -4)); //"lo w"
    alert(stringValue.substring(3, -4)); //"hel"
    alert(stringValue.substr(3, -4)); //""（空字符串）
    ```

  - - 传递一个负值参数时

    - - -3 会被转换为8（字符串长度加参数11+(-3)=8），实际上相当于调用了slice(8)和substr(8)。

      - - IE 的JavaScript 实现在处理向substr()方法传递负值的情况时存在问题，它会返回原始的字符串。IE9 修复了这个问题。

      - substring()方法则返回了全部字符串，因为它将-3 转换成了0。

    - 第二个参数是负值时

    - - slice()方法会把第二个参数转换为7，这就相当于调用了slice(3,7)
      - substr()也会将第二个参数转换为0，这也就意味着返回包含零个字符的字符串，也就是一个空字符串。
      - substring()方法会把第二个参数转换为0，使调用变成了substring(3,0)，而由于这个方法会将较小的数作为开始位置，将较大的数作为结束位置，因此最终相当于调用了substring(0,3)。

**字符串位置方法**：

有两个可以从字符串中**查找子字符串**的方法：indexOf()和lastIndexOf()。这两个方法都是从一个字符串中搜索给定的子字符串，然后返子**字符串的位置**（如果没有找到该子字符串，则返回-1）。

- indexOf()方法从字符串的开头向后搜索子字符串

- lastIndexOf()方法是从字符串的末尾向前搜索子字符串。

  ```js
  var stringValue = "hello world";
  alert(stringValue.indexOf("o")); //4
  alert(stringValue.lastIndexOf("o")); //7
  ```

  - 两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。（都指从左到右位置）

    ```js
    var stringValue = "hello world";
    alert(stringValue.indexOf("o", 6)); //7
    alert(stringValue.lastIndexOf("o", 6)); //4
    ```

  - 在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串

    ```js
    var stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";
    var positions = new Array();
    var pos = stringValue.indexOf("e");
    
    while(pos > -1){
    	positions.push(pos);
    	pos = stringValue.indexOf("e", pos + 1);
    }
    
    alert(positions); //"3,24,32,35,52"
    ```

**trim()方法**：

- trim()方法会创建一个字符串的副本，删除**前置及后缀**的所有空格，然后返回结果。ECMAScript 5 为所有字符串定义了trim()方法。（**trim /trɪm/ 装饰**）

  ```js
  var stringValue = " hello world ";
  var trimmedStringValue = stringValue.trim();
  alert(stringValue); //" hello world "
  alert(trimmedStringValue); //"hello world"
  ```
  - 原始字符串中的前置及后缀空格会保持不变。
  - 支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和Chrome。此外，Firefox 3.5+、Safari 5+和Chrome 8+
  - 还支持非标准的trimLeft()和trimRight()方法，分别用于删除字符串开头和末尾的空格。

**字符串大小写转换方法**：

ECMAScript 中涉及字符串大小写转换的方法有4 个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。

- toLowerCase()和toUpperCase()是两个经典的方法，借鉴自java.lang.String 中的同名方法。

- toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现。

  ```js
  var stringValue = "hello world";
  alert(stringValue.toLocaleUpperCase()); //"HELLO WORLD"
  alert(stringValue.toUpperCase()); //"HELLO WORLD"
  alert(stringValue.toLocaleLowerCase()); //"hello world"
  alert(stringValue.toLowerCase()); //"hello world"
  ```

- - 对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为Unicode 大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。
  - 使用针对地区的方法更稳妥一些。

**字符串的模式匹配方法**：

String 类型定义了几个用于在字符串中**匹配模式**的方法。

- match()，在字符串上调用这个方法，本质上与调用RegExp 的exec()方法相同。（**match /mætʃ/ 比赛**）

  ```js
  var text = "cat, bat, sat, fat";
  var pattern = /.at/;
  
  //与pattern.exec(text)相同
  var matches = text.match(pattern);
  alert(matches.index); //0
  alert(matches[0]); //"cat"
  alert(pattern.lastIndex); //0
  ```

1. - match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp 对象。
   - 返回了一个数组；
   - 与调用RegExp 对象的exec()方法并传递本例中的字符串作为参数相同的数组
   - 数组的第一项是与**整个模式匹配**的字符串，之后的每一项（如果有）保存着与正则表达式中的**捕获组匹配**的字符串。

- search()方法返回字符串中第一个匹配项的**索引**(如果没有找到匹配项，则返回-1)。

  ```js
  var text = "cat, bat, sat, fat";
  var pos = text.search(/at/);
  alert(pos); //1
  ```

- - search()方法的唯一参数与match()方法的参数相同：由字符串或RegExp 对象指定的一个正则表达式。
  - 而且，search()方法始终是从字符串开头向后查找模式。

- replace()方法，ECMAScript 提供了为了**简化替换**子字符串的操作。

  ```js
  var text = "cat, bat, sat, fat";
  var result = text.replace("at", "ond");
  alert(result); //"cond, bat, sat, fat"
  
  result = text.replace(/at/g, "ond");
  alert(result); //"cond, bond, sond, fond"
  ```

- - 这个方法接受两个参数：第一个参数可以是一个RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。

  - 如果第一个参数是字符串，那么只会替换第一个子字符串。

  - 要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志

  - 如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。

    | 字符序列 | 替换文本                                                     |
    | -------- | ------------------------------------------------------------ |
    | $$       | $                                                            |
    | $&       | 匹配整个模式的子字符串。与RegExp.lastMatch的值相同           |
    | $'       | 匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同   |
    | $`       | 匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同  |
    | $n       | 匹配第n个**捕获组的子字符串**，其中n等于0～9。例如，$1是匹配第一个捕获组的子字符串，$2是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串（理解：**捕获组的子字符串，整个模式是第一个捕获组**） |
    | $nn      | 匹配第nn个捕获组的子字符串，其中nn等于01～99。例如，$01是匹配第一个捕获组的子字符串，$02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串 |

    ```js
    var text = "cat, bat, sat, fat";
    result = text.replace(/(.at)/g, "word ($1)");
    alert(result); //word (cat), word (bat), word (sat), word (fat)
    ```

  - 第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3 个参数：模式的**匹配项**、**模式匹配项**在字符串中的**位置**和**原始字符串**。

    ```js
    function htmlEscape(text){
    	return text.replace(/[<>"&]/g, function(match, pos, originalText){
    		switch(match){
    		case "<":
    			return "&lt;";
    		case ">":
    			return "&gt;";
    		case "&":
    			return "&amp;";
    		case "\"":
    			return "&quot;";
    		}
    	});
    }
    
    alert(htmlEscape("<p class=\"greeting\">Hello world!</p>"));
    //&lt;p class=&quot;greeting&quot;&gt;Hello world!&lt;/p&gt;
    ```

  - - 在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。
    - 这个函数应该返回一个字符串，表示应该被替换的匹配项
    - 使用函数作为replace()方法的第二个参数可以实现更加精细的替换操作
    - 函数htmlEscape()能够转义4 个字符：小于号、大于号、和号以及双引号。
    - 实现这种转义的最简单方式，就是使用正则表达式查找这几个字符，然后定义一个能够针对每个匹配的字符返回特定HTML 实体的函数。

- split()方法可以**基于指定的分隔符**将一个字符串分割成多个子字符串，并将结果放在一个数组中。

  ```js
  var colorText = "red,blue,green,yellow";
  var colors1 = colorText.split(","); //["red", "blue", "green", "yellow"]
  var colors2 = colorText.split(",", 2); //["red", "blue"]
  var colors3 = colorText.split(/[^\,]+/); //["", ",", ",", ",", ""]
  ```

- - 分隔符可以是字符串，也可以是一个RegExp 对象（这个方法不会将字符串看成正则表达式）
  - 可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。
  - 使用正则表达式取得包含逗号字符的数组。
  - 注意的是，在最后一次调用split()返回的数组中，第一项和最后一项是两个空字符串。之所以会这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头（即子字符串"red"）和末尾（即子字符串"yellow"）。（不够理解）

- - split()中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现匹配项以及带有捕获组的模式，匹配的行为就不大相同了。以下是几种常见的差别。
    - IE8 及之前版本会忽略捕获组。ECMA-262 规定应该把捕获组拼接到结果数组中。IE9 能正确地在结果中包含捕获组。
    - Firefox 3.6 及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；ECMA-262 规定没有匹配项的捕获组在结果数组中应该用undefined 表示。
    - 在正则表达式中使用捕获组时还有其他微妙的差别。在使用这种正则表达式时，一定要在各种浏览器下多做一些测试。
    - 要了解关于split()方法以及捕获组的跨浏览器问题的更多讨论，请参考Steven Levithan 的文章“JavaScript split     bugs：Fixed!”（http://blog.stevenlevithan.com/archives/cross-browser-split）。

**localeCompare()方法**：

- localeCompare()方法，与操作字符串有关的最后一个方法是localeCompare()，这个方法**比较两个字符串**，并返回下列值中的一个：（**Compare /kəmˈpeə(r)/ 比较**）

  ```js
  var stringValue = "yellow";
  alert(stringValue.localeCompare("brick")); //1
  alert(stringValue.localeCompare("yellow")); //0
  alert(stringValue.localeCompare("zoo")); //-1
  ```

- - 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（**大多数**情况下是-1，具体的值要视实现而定）；

  - 如果字符串等于字符串参数，则返回0；

  - 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要视实现而定）

  - 因为localeCompare()返回的数值取决于实现，所以最好是像下面例子所示的这样使用这个方法。

    ```js
    function determineOrder(value) {
    	var result = stringValue.localeCompare(value);
    	if (result < 0){
    		alert("The string 'yellow' comes before the string '" + value + "'.");
    	} else if (result > 0) {
    		alert("The string 'yellow' comes after the string '" + value + "'.");
    	} else {
    		alert("The string 'yellow' is equal to the string '" + value + "'.");
    	}
    }
    
    determineOrder("brick");
    determineOrder("yellow");
    determineOrder("zoo");
    ```

  - localeCompare()方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个方法的行为。

  - - 比如，美国以英语作为ECMAScript 实现的标准语言，因此localeCompare()就是区分大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。
    - 不过，在其他地区恐怕就不是这种情况了。

**fromCharCode()方法**：

- fromCharCode()方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。

  ```js
  alert(String.fromCharCode(104, 101, 108, 108, 111)); //"hello"
  ```

- - String 构造函数本身还有一个静态方法。
  - 从本质上来看，这个方法与实例方法charCodeAt()执行的是相反的操作。

**HTML 方法**：

- HTML 方法，早期的Web 浏览器提供商觉察到了使用JavaScript 动态格式化HTML 的需求。于是，这些提供商就扩展了标准，实现了一些专门用于简化常见HTML 格式化任务的方法。

  | 方 法            | 输出结果                           | 输出结果                            |
  | ---------------- | ---------------------------------- | ----------------------------------- |
  | anchor(name)     | <a name=  "name">string</a>        | \<a name= "name">string\</a>        |
  | big()            | <big>string</big>                  | \<big>string\</big>                 |
  | bold()           | <b>string</b>                      | \<b>string\</b>                     |
  | fixed()          | <tt>string</tt>                    | \<tt>string\</tt>                   |
  | fontcolor(color) | <font  color="color">string</font> | \<font color="color">string\</font> |
  | fontsize(size)   | <font  size="size">string</font>   | \<font size="size">string\</font>   |
  | italics()        | <i>string</i>                      | \<i>string\</i>                     |
  | link(url)        | <a  href="url">string</a>          | \<a href="url">string\</a>          |
  | small()          | <small>string</small>              | \<small>string\</small>             |
  | strike()         | <strike>string</strike>            | \<strike>string\</strike>           |
  | sub()            | <sub>string</sub>                  | \<sub>string\</sub>                 |
  | sup()            | <sup>string</sup>                  | \<sup>string\</sup>                 |

- - 注意：应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。

### 5.7 单体内置对象

***1. 内置对象与单体内置对象***

ECMA-262 对内置对象的定义是：“由ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript 程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们**已经实例化**了。

- 前面我们已经介绍了大多数内置对象，

- - 例如Object、Array 和String。

- ECMA-262 还定义了两个单体内置对象：

- - Global 和Math。

#### 5.7.1 Global对象

***1. Global（全局）对象***

Global（全局）对象可以说是ECMAScript 中最特别的一个对象了，因为不管你从什么角度上看，**这个对象都是不存在的**。

ECMAScript 中的Global 对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。

事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global 对象的属性。

***2. Global 对象的方法***

前面介绍过的那些函数，诸如isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global对象的方法。

***3. Global 对象的其他方法***

除此之外，Global 对象还包含其他一些方法。

**URI 编码方法**：

Global 对象的encodeURI()和encodeURIComponent()方法可以对URI（Uniform ResourceIdentifiers，通用资源标识符）进行编码，以便发送给浏览器。

- - 有效的URI 中不能包含某些字符，例如**空格**。
  - 而这两个URI 编码方法就可以对URI 进行编码，它们用**特殊的UTF-8 编码**替换所有无效的字符，从而让浏览器能够接受和理解。

- encodeURI()主要用于整个URI（例如，http://www.wrox.com/illegal     value.htm）进行**编码**。

- encodeURIComponent()主要用于对URI 中的某一段（例如前面URI 中的illegal value.htm）进行编码。

  ```js
  var uri = "http://www.wrox.com/illegal value.htm#start";
  
  //"http://www.wrox.com/illegal%20value.htm#start"
  alert(encodeURI(uri));
  
  //"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"
  alert(encodeURIComponent(uri));
  ```

- - encodeURI()不会对本身属于URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；
  - encodeURIComponent()则会对它发现的任何非标准字符进行编码。
  - 使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。
  - 而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。
  - 这也正是可以对整个URI 使用encodeURI()，而只能对附加在现有URI 后面的字符串使用encodeURIComponent()的原因所在。
  - 一般来说， 我们使用encodeURIComponent() 方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码。

**URI 解码方法**：

与encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent()。

- decodeURI()只能对使用encodeURI()替换的字符进行**解码**。

- - 可将%20 替换成一个空格
  - 不会对%23 作任何处理，因为%23 表示井字号（#），而井字号不是使用encodeURI()替换的

- decodeURIComponent()能够解码使用encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码。

  ```js
  var uri = "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start";
  
  //http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start
  alert(decodeURI(uri));
  
  //http://www.wrox.com/illegal value.htm#start
  alert(decodeURIComponent(uri));
  ```

  - decodeURI()输出的结果中，只有%20 被替换成了空格。
  - decodeURIComponent()输出的结果中，所有特殊字符的编码都被替换成了原来的字符，得到了一个未经转义的字符串（但这个字符串并不是一个有效的URI）。
  - URI 方法encodeURI()、encodeURIComponent()、decodeURI()和decodeURIComponent()用于替代已经被ECMA-262 第3 版废弃的escape()和unescape()方法。URI 方法能够编码所有Unicode 字符，而原来的方法只能正确地编码ASCII 字符。因此在开发实践中，特别是在产品级的代码中，一定要使用URI 方法，不要使用escape()和unescape()方法。

**eval()方法**：

- eval()方法就像是一个**完整的ECMAScript 解析器**，它只接受一个参数，即要执行的ECMAScript （或JavaScript）字符串。

  ```js
  eval("alert('hi')");
  // 等价于
  alert("hi");
  ```

  - 是我们介绍最后一个——大概也是整个ECMAScript 语言中最强大的一个方法

  - 当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript 语句来解析，然后把执行结果插入到原位置。

  - 通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码**具有与该执行环境相同的作用域链**。这意味着

  - - 通过eval()执行的代码可以引用在包含环境中定义的变量

      ```js
      eval("function sayHi() { alert('hi'); }");
      sayHi();
      ```

    - 由于对eval()的调用最终会被替换成定义函数的实际代码，因此可以在下一行调用

      ```js
      eval("var msg = 'hello world'; ");
      alert(msg); //"hello world"
      ```

  - 严格模式下，在外部访问不到eval()中创建的任何变量或函数，因此前面两个例子都会导致错误。同样，在严格模式下，为eval 赋值也会导致错误：

    ```js
    "use strict";
    eval = "hi"; //causes error
    ```

  - 能够解释代码字符串的能力非常强大，但也非常危险。因此在使用eval()时必须极为谨慎，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的**代码注入**）。

***4. Global 对象的属性***

Global 对象还包含一些属性，其中一部分属性已经在本书前面介绍过了。例如：

- 特殊的值undefined、NaN 以及Infinity 都是Global 对象的属性。

- 此外，所有原生引用类型的构造函数，像Object 和Function，也都是Global 对象的属性。

  | 属 性     | 说 明            | 属 性          | 说 明                  |
  | --------- | ---------------- | -------------- | ---------------------- |
  | undefined | 特殊值undefined  | Date           | 构造函数Date           |
  | NaN       | 特殊值NaN        | RegExp         | 构造函数RegExp         |
  | Infinity  | 特殊值Infinity   | Error          | 构造函数Error          |
  | Object    | 构造函数Object   | EvalError      | 构造函数EvalError      |
  | Array     | 构造函数Array    | RangeError     | 构造函数RangeError     |
  | Function  | 构造函数Function | ReferenceError | 构造函数ReferenceError |
  | Boolean   | 构造函数Boolean  | SyntaxError    | 构造函数SyntaxError    |
  | String    | 构造函数String   | TypeError      | 构造函数TypeError      |
  | Number    | 构造函数Number   | URIError       | 构造函数URIError       |

- ECMAScript 5 明确禁止给undefined、NaN 和Infinity 赋值，这样做即使在非严格模式下也会导致错误。

***5. window 对象（简单介绍，以理解Global ）***

ECMAScript 虽然没有指出如何直接访问Global 对象，但Web 浏览器都是将这个全局对象作为window 对象的一部分加以实现的。

- 在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。

  ```js
  var color = "red";
  function sayColor(){
  	alert(window.color);
  }
  window.sayColor(); //"red"
  ```

  - JavaScript中的window 对象除了扮演ECMAScript规定的Global 对象的角色外，还承担了很多别的任务。（第8 章在讨论浏览器对象模型时将详细介绍window 对象。）

- 另一种取得Global 对象的方法是使用以下代码：

  ```js
  var global = function(){
  	return this;
  }();
  ```

  - 在没有给函数明确指定this 值的情况下（无论是通过将函数添加为对象的方法，还是通过调用call()或apply()），this值等于Global 对象。
  - 而像这样通过简单地返回this 来取得Global 对象，在任何执行环境下都是可行的。（第7 章将深入讨论函数表达式。）

#### 5.7.2 Math对象

ECMAScript 还为保存数学公式和信息提供了一个公共位置，即Math 对象。

***1. Math 对象的属性***

Math 对象包含的属性大都是数学计算中可能会用到的一些特殊值。

| 属 性        | 说 明                            |
| ------------ | -------------------------------- |
| Math.E       | 自然对数的底数，即常量e的值      |
| Math.LN10    | 10的自然对数                     |
| Math.LN2     | 2的自然对数                      |
| Math.LOG2E   | 以2为底e的对数                   |
| Math.LOG10E  | 以10为底e的对数                  |
| Math.PI      | π的值                            |
| Math.SQRT1_2 | 1/2的平方根（即2的平方根的倒数） |
| Math.SQRT2   | 2的平方根                        |

***2. Math 对象的方法***

**min()和max()方法**：

- Math 对象还包含许多方法，用于辅助完成简单和复杂的数学计算。

- 其中，min()和max()方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数

  ```js
  var max = Math.max(3, 54, 32, 16);
  alert(max); //54
  
  var min = Math.min(3, 54, 32, 16);
  alert(min); //3
  ```

- 两个方法经常用于避免多余的循环和在if 语句中确定一组数的最大值。

  ```js
  var values = [1, 2, 3, 4, 5, 6, 7, 8];
  var max = Math.max.apply(Math, values);
  ```
  - 这个技巧的关键是把Math 对象作为apply()的第一个参数，从而正确地设置this值。然后，可以将任何数组作为第二个参数。（见5.5.5）

**舍入方法**：

将小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round()。

- Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；

- Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；

- Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课上学到的舍入规则）。

  ```js
  alert(Math.ceil(25.9)); //26
  alert(Math.ceil(25.5)); //26
  alert(Math.ceil(25.1)); //26
  
  alert(Math.round(25.9)); //26
  alert(Math.round(25.5)); //26
  alert(Math.round(25.1)); //25
  
  alert(Math.floor(25.9)); //25
  alert(Math.floor(25.5)); //25
  alert(Math.floor(25.1)); //25
  ```

**random()方法**：

- Math.random()方法返回大于等于0 小于1 的一个随机数。

- 套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。

  ```js
  值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)
  ```
  - 公式中用到了Math.floor()方法，这是因为Math.random()总返回一个小数值。而用这个小数值乘以一个整数，然后再加上一个整数，最终结果仍然还是一个小数。

- 举例：

- - 选择一个1到10 之间的数值

    ```js
    var num = Math.floor(Math.random() * 10 + 1);
    ```

  - 选择一个介于2 到10 之间的数值

    ```js
    var num = Math.floor(Math.random() * 9 + 2);
    ```

  - 多数情况下，其实都可以通过一个函数来计算可能值的总数和第一个可能的值

    ```js
    function selectFrom(lowerValue, upperValue) {
    	var choices = upperValue - lowerValue + 1;
    	return Math.floor(Math.random() * choices + lowerValue);
    }
    
    var num = selectFrom(2, 10);
    aler t(num); // 介于 2 和10 之间（包括 2 和 10）的一个数值
    ```

    - 利用这个函数，可以方便地从数组中随机取出一项

      ```js
      var colors = ["red", "green", "blue", "yellow", "black", "purple", "brown"];
      var color = colors[selectFrom(0, colors.length-1)];
      aler t(color); // 可能是数组中包含的任何一个字符串
      ```

**其他方法**：

Math 对象中还包含其他一些与完成各种简单或复杂计算有关的方法，但详细讨论其中每一个方法的细节及适用情形超出了本书的范围。

| 方 法               | 说 明                 | 方 法           | 说 明              |
| ------------------- | --------------------- | --------------- | ------------------ |
| Math.abs(num)       | 返回num 的绝对值      | Math.asin(x)    | 返回x 的反正弦值   |
| Math.exp(num)       | 返回Math.E 的num 次幂 | Math.atan(x)    | 返回x 的反正切值   |
| Math.log(num)       | 返回num 的自然对数    | Math.atan2(y,x) | 返回y/x 的反正切值 |
| Math.pow(num,power) | 返回num 的power 次幂  | Math.cos(x)     | 返回x 的余弦值     |
| Math.sqrt(num)      | 返回num 的平方根      | Math.sin(x)     | 返回x 的正弦值     |
| Math.acos(x)        | 返回x 的反余弦值      | Math.tan(x)     | 返回x 的正切值     |

- 虽然ECMA-262 规定了这些方法，但不同实现可能会对这些方法采用不同的算法。毕竟，计算某个值的正弦、余弦和正切的方式多种多样。也正因为如此，这些方法在不同的实现中可能会有不同的精度。

### 5.8 小结

***1. 内置的引用类型***

**对象**在JavaScript 中被称为**引用类型的值**，而且有一些**内置的引用类型**可以用来创建**特定的对象**，现简要总结如下：

- 引用类型与传统面向对象程序设计中的类相似，但实现不同；
- Object 是一个基础类型，其他所有类型都从Object 继承了基本的行为；
- Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；
- Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
- RegExp 类型是ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能。

***2. Function 类型***

函数实际上是Function 类型的实例，因此函数也是对象；而这一点正是JavaScript 最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。

***3. 基本包装类型***

因为有了基本包装类型，所以JavaScript 中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number 和String。以下是它们共同的特征：

- 每个包装类型都映射到同名的基本类型；
- 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作；
- 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。

***4. 内置对象***

在所有代码执行之前，作用域中就已经存在两个内置对象：Global 和Math。在大多数ECMAScript实现中都不能直接访问Global 对象；不过，Web 浏览器实现了承担该角色的window 对象。全局变量和函数都是Global 对象的属性。Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。